package juego;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashMap;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

import clases.Mario;
import clases.TileElement;

public class Juego extends Canvas implements KeyListener{
	private JFrame ventana;
	private BufferStrategy dobleBuffer;
	private Graphics2D g2D;

	private boolean jugando  = false;

	public static final int ANCHO_VENTANA = 700/*DEFINA SUS PROPIAS DIMENSIONES*/;
	public static final int ALTO_VENTANA = 500/*DEFINA SUS PROPIAS DIMENSIONES*/;

	int lastFpsTime; //Variable auxiliar para calculo de la pausa del ciclo principal
	int fps; //Fotogramas por segundo

	private int tileMap[][]={
			{1 , 2 , 3 ,4 , 5 ,6 },
			{7 , 8 , 9 ,10, 11,12},
			{13, 14, 15,16, 17,18},
			{19, 20, 21,22, 23,24},
			{25, 5 , 5 ,5 , 5 ,5 },
			{6 , 6 , 6 ,6 , 6 ,6 },
			{7 , 7 , 7 ,7 , 7 ,7 },
			{8 , 8 , 8 ,8 , 8 ,8 },
			{9 , 9 , 9 ,9 , 9 ,9 }

	};
	private TileElement tile;
	private Mario jugador;
	public static boolean presionoIzquierda;
	public static boolean presionoDerecha;
	public static boolean presionoArriba;
	public static boolean presionoAbajo;

	public static HashMap<String,BufferedImage> imagenes = new HashMap<String,BufferedImage>();

	public Juego(){
		cargarImagenes();
		inicializarObjetosJuego();
		incializarVentana();

		createBufferStrategy(2); //Crear una estrategia de doble buffer (metodo optimo para videojuegos)
		dobleBuffer = getBufferStrategy(); //Obtener una instancia de BufferStrategy (para luego dibujar los componentes)

		jugando = true; //Definir la variable logica de juego en true

		this.requestFocus(); //Solicitar el foco para que los eventos del teclado puedan ser capturados por el Canvas.
		this.addKeyListener(this); //Agregar interfaz de escucha para poder interceptar las teclas pulsadas por el usuario.

		cicloPrincipal(); //Ejecutar el ciclo principal del juego (Este no necesariamente debe llamarse desde aqui)
	}

	public void incializarVentana(){
		//Crear la ventana y establecer sus propiedades
		ventana = new JFrame(); //Crear instancia de la ventana
		ventana.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //Terminar aplicacion cuando se de click en la X
		ventana.setSize(ANCHO_VENTANA, ALTO_VENTANA); //Establecer las dimensiones de la ventana
		ventana.setLocationRelativeTo(null); //Centrar ventana en el escritorio
		//ventana.setResizable(false);
		//Ventana en fullscreen
		//ventana.setExtendedState(JFrame.MAXIMIZED_BOTH);
		//ventana.setUndecorated(true);
		ventana.setTitle("Establezca el titulo de su conveniencia"); //Definir el titulo de la ventana
		ventana.getContentPane().add(this); //Agregar el Canvas (lienzo) a la ventana
		ventana.setVisible(true); //Mostrar ventana
	}

	public void inicializarObjetosJuego(){
		jugador = new Mario("Mario",10,10,2,"mario");
	}

	//Cargar Imagenes
	public void cargarImagenes(){
		//Es mas conveniente almacenar las imagenes en un hashmap para poder darle un alias.
		try {
			BufferedImage spritesAuto = ImageIO.read(getClass().getResource("/recursos/tiles_spritesheet.png"));
			imagenes.put("mario", ImageIO.read(getClass().getResource("/recursos/mario.png")));
			imagenes.put("tile1", spritesAuto.getSubimage(0, 0, 70, 70));
			imagenes.put("tile2", spritesAuto.getSubimage(0, 73, 70, 70));
			imagenes.put("tile3", spritesAuto.getSubimage(0, 145, 70, 70));
			imagenes.put("tile4", spritesAuto.getSubimage(0, 217, 70, 70));
			imagenes.put("tile5", spritesAuto.getSubimage(0, 289, 70, 70));
			imagenes.put("tile6", spritesAuto.getSubimage(0, 361, 70, 70));
			imagenes.put("tile7", spritesAuto.getSubimage(0, 433, 70, 70));
			imagenes.put("tile8", spritesAuto.getSubimage(0, 505, 70, 70));
			imagenes.put("tile10", spritesAuto.getSubimage(0, 577, 70, 70));
			imagenes.put("tile11", spritesAuto.getSubimage(0, 577, 70, 70));
			imagenes.put("tile12", spritesAuto.getSubimage(0, 577, 70, 70));
			imagenes.put("tile13", spritesAuto.getSubimage(0, 577, 70, 70));

			imagenes.put("tile14", spritesAuto.getSubimage(73, 0, 70, 70));
			imagenes.put("tile15", spritesAuto.getSubimage(73, 73, 70, 70));
			imagenes.put("tile16", spritesAuto.getSubimage(73, 145, 70, 70));
			imagenes.put("tile17", spritesAuto.getSubimage(73, 217, 70, 70));
			imagenes.put("tile18", spritesAuto.getSubimage(73, 289, 70, 70));
			imagenes.put("tile19", spritesAuto.getSubimage(73, 361, 70, 70));
			imagenes.put("tile20", spritesAuto.getSubimage(73, 433, 70, 70));
			imagenes.put("tile21", spritesAuto.getSubimage(73, 505, 70, 70));
			imagenes.put("tile22", spritesAuto.getSubimage(73, 577, 70, 70));
			imagenes.put("tile23", spritesAuto.getSubimage(73, 577, 70, 70));
			imagenes.put("tile24", spritesAuto.getSubimage(73, 577, 70, 70));
			imagenes.put("tile25", spritesAuto.getSubimage(73, 577, 70, 70));

		} catch (IOException e) {
			e.printStackTrace();
		}
	}


	//Metodo para pintar los componentes del juego
	private void pintar(){
        g2D = (Graphics2D)dobleBuffer.getDrawGraphics(); //Obtener la instancia de Graphics para pintar los elementos

        //Puede borrar las siguientes 4 lineas
        g2D.setColor(new Color(139,225,235)); //Definir el color negro en el contexto
        g2D.fillRect(0, 0, ANCHO_VENTANA, ALTO_VENTANA); //Dibujar un rectangulo
        g2D.setColor(Color.WHITE); //Definir el color blanco en el contexto

        //Pintar objetos de juego
        for(int i=0;i<tileMap.length;i++)
        	for(int j=0;j<tileMap[0].length;j++)
        		g2D.drawImage(imagenes.get("tile"+tileMap[i][j]), i*70, j*70, this);


        jugador.pintar(g2D, this);
        dobleBuffer.show(); //Mostrar lo que se ha dibujado
	}

	public void actualizar(){
		//Agregue aqui el codigo necesario para actualizar los componentes de juego y construir la logica del juego
		jugador.mover();
	}

	public void cicloPrincipal(){
       //variables para el calculo del tiempo para la pausa, este codigo es opcional, si lo desea puede definir un valor para la pausa en duro.
	   long lastLoopTime = System.nanoTime();
       final int TARGET_FPS = 60;
       final long OPTIMAL_TIME = 1000000000 / TARGET_FPS;

       while (jugando){
    	   //Calculo del tiempo optimo y uniforme para la pausa.
    	   long now = System.nanoTime();
    	   long updateLength = now - lastLoopTime;
    	   lastLoopTime = now;
    	   double delta = updateLength / ((double)OPTIMAL_TIME);
    	   lastFpsTime += updateLength;
    	   fps++;
    	   if (lastFpsTime >= 1000000000){
    		   System.out.println("(FPS: "+fps+")");
    		   lastFpsTime = 0;
    		   fps = 0;
    	   }
    	   //Fin del calculo del tiempo optimo y uniforme para la pausa.

    	   //Metodos para pintar el lienzo y actualizar los componentes de juego
    	   pintar();
    	   actualizar();

    	   //Aplicar la pausa.
    	   try{Thread.sleep((lastLoopTime-System.nanoTime() + OPTIMAL_TIME)/1000000 );} //Puede sustituir el valor de la pausa por un valor fijo
    	   catch(Exception e){};
       }
    }

	//Metodo que se ejecuta cuando el usuario presiona una tecla
	public void keyPressed(KeyEvent e){
        switch(e.getKeyCode()){
        	case KeyEvent.VK_LEFT:
        		presionoIzquierda=true;
        		break;
        	case KeyEvent.VK_RIGHT:
        		presionoDerecha=true;
        		break;
        	case KeyEvent.VK_UP:
        		presionoArriba=true;
        		break;
        	case KeyEvent.VK_DOWN:
        		presionoAbajo=true;
        		break;
        }
    }

	//Metodo que se ejecuta cuando el usuario suelta una tecla
    public void keyReleased(KeyEvent e) {
        switch(e.getKeyCode()){
	        case KeyEvent.VK_LEFT:
	    		presionoIzquierda=false;
	    		break;
	    	case KeyEvent.VK_RIGHT:
	    		presionoDerecha=false;
	    		break;
	    	case KeyEvent.VK_UP:
	    		presionoArriba=false;
	    		break;
	    	case KeyEvent.VK_DOWN:
	    		presionoAbajo=false;
	    		break;
        }
    }
    //Sin uso, pero a fuerzas se debe redefinir
  	public void keyTyped(KeyEvent e) {}

    public static void main(String[] args){
		new Juego(); //Crear un objeto del tipo Juego.
	}
}